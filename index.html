<!doctype html>
<html lang="en" ng-app="rogueGame">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Neon Bomber: Gridfall Arena</title>
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600;700&family=Inter:wght@400;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        color-scheme: dark;
        font-family: "Inter", system-ui, -apple-system, sans-serif;
      }

      body {
        min-height: 100vh;
        background: radial-gradient(circle at top, #1b2847 0%, #0a0f1c 55%, #05070d 100%);
        color: #e2e8f0;
      }

      .glow {
        box-shadow: 0 0 25px rgba(56, 189, 248, 0.35);
      }

      .title {
        font-family: "Orbitron", sans-serif;
        letter-spacing: 0.08em;
      }

      .panel {
        background: rgba(15, 23, 42, 0.92);
        border: 1px solid rgba(148, 163, 184, 0.2);
        border-radius: 18px;
      }

      .board {
        display: grid;
        grid-template-columns: repeat(9, 1fr);
        gap: 0.4rem;
        padding: 1.2rem;
        border-radius: 18px;
        background: linear-gradient(145deg, rgba(15, 23, 42, 0.85), rgba(30, 41, 59, 0.9));
      }

      .cell {
        aspect-ratio: 1 / 1;
        border-radius: 10px;
        background: rgba(148, 163, 184, 0.08);
        border: 1px solid rgba(148, 163, 184, 0.15);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.2rem;
        position: relative;
        overflow: hidden;
        transition: transform 0.2s ease, background 0.2s ease, border 0.2s ease,
          box-shadow 0.2s ease;
      }

      .cell::after {
        content: "";
        position: absolute;
        inset: 0;
        background: radial-gradient(circle, rgba(56, 189, 248, 0.15) 0%, transparent 65%);
        opacity: 0;
        transition: opacity 0.2s ease;
      }

      .cell.highlight::after {
        opacity: 1;
      }

      .player {
        background: linear-gradient(135deg, rgba(34, 211, 238, 0.35), rgba(59, 130, 246, 0.35));
        border: 1px solid rgba(34, 211, 238, 0.6);
      }

      .enemy {
        background: linear-gradient(135deg, rgba(248, 113, 113, 0.3), rgba(239, 68, 68, 0.35));
        border: 1px solid rgba(248, 113, 113, 0.6);
      }

      .loot {
        background: linear-gradient(135deg, rgba(250, 204, 21, 0.25), rgba(234, 179, 8, 0.35));
        border: 1px solid rgba(250, 204, 21, 0.6);
      }

      .wall {
        background: linear-gradient(135deg, rgba(148, 163, 184, 0.25), rgba(71, 85, 105, 0.4));
        border: 1px solid rgba(148, 163, 184, 0.45);
      }

      .bomb {
        background: radial-gradient(circle, rgba(248, 250, 252, 0.35), rgba(148, 163, 184, 0.2));
        border: 1px solid rgba(226, 232, 240, 0.7);
      }

      .explosion {
        background: radial-gradient(circle, rgba(248, 113, 113, 0.5), rgba(248, 113, 113, 0.2));
        border: 1px solid rgba(248, 113, 113, 0.8);
        box-shadow: 0 0 12px rgba(248, 113, 113, 0.6);
      }

      .shielded {
        box-shadow: 0 0 15px rgba(56, 189, 248, 0.8) inset;
      }

      .stat-pill {
        background: rgba(30, 41, 59, 0.8);
        border-radius: 999px;
        padding: 0.35rem 0.75rem;
        font-size: 0.85rem;
      }

      .log {
        max-height: 220px;
        overflow-y: auto;
        font-size: 0.9rem;
      }

      .mini-bar {
        height: 8px;
        background: rgba(148, 163, 184, 0.3);
        border-radius: 999px;
        overflow: hidden;
      }

      .mini-bar span {
        display: block;
        height: 100%;
        background: linear-gradient(90deg, #38bdf8, #22d3ee);
      }

      .legend span {
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        margin-right: 0.75rem;
      }

      .legend .dot {
        width: 0.7rem;
        height: 0.7rem;
        border-radius: 50%;
        display: inline-block;
      }

      .floating-card {
        background: rgba(15, 23, 42, 0.85);
        border: 1px solid rgba(148, 163, 184, 0.3);
        border-radius: 16px;
        padding: 1rem;
      }

      .accent {
        color: #38bdf8;
      }
    </style>
  </head>
  <body ng-controller="GameController as vm" class="py-4">
    <div class="container">
      <div class="d-flex flex-wrap justify-content-between align-items-center mb-4 gap-3">
        <div>
          <h1 class="title mb-1">Neon Bomber: Gridfall Arena</h1>
          <p class="mb-0 text-secondary">
            Plant bombs, clear crates, and outlast the rogue drones in the neon grid.
          </p>
        </div>
        <div class="d-flex gap-2">
          <button class="btn btn-info text-dark fw-semibold" ng-click="vm.restart()">
            Restart Run
          </button>
          <button class="btn btn-outline-light" ng-click="vm.togglePause()">
            {{ vm.paused ? 'Resume' : 'Pause' }}
          </button>
        </div>
      </div>

      <div class="row g-4">
        <div class="col-lg-7">
          <div class="panel p-3 glow">
            <div class="d-flex justify-content-between align-items-center flex-wrap gap-2 mb-3">
              <div>
                <div class="text-uppercase text-info small">Stage {{ vm.stage }}</div>
                <div class="fs-5 fw-semibold">Arena {{ vm.biome }}</div>
              </div>
              <div class="legend text-secondary small">
                <span><span class="dot bg-info"></span>Hero</span>
                <span><span class="dot bg-danger"></span>Enemy</span>
                <span><span class="dot bg-warning"></span>Crate</span>
                <span><span class="dot bg-secondary"></span>Wall</span>
                <span><span class="dot bg-light"></span>Bomb</span>
              </div>
            </div>
            <div class="board">
              <div
                class="cell"
                ng-repeat="cell in vm.board track by $index"
                ng-class="{
                  player: cell.type === 'player',
                  enemy: cell.type === 'enemy',
                  loot: cell.type === 'crate',
                  wall: cell.type === 'wall',
                  bomb: cell.type === 'bomb',
                  explosion: cell.type === 'explosion',
                  highlight: cell.highlight,
                  shielded: cell.shielded
                }"
              >
                <span ng-if="cell.type === 'player'">ðŸ™‚</span>
                <span ng-if="cell.type === 'enemy'">ðŸ¤–</span>
                <span ng-if="cell.type === 'crate'">ðŸ“¦</span>
                <span ng-if="cell.type === 'wall'">ðŸ§±</span>
                <span ng-if="cell.type === 'bomb'">ðŸ’£</span>
                <span ng-if="cell.type === 'explosion'">ðŸ’¥</span>
              </div>
            </div>
            <div class="mt-3 d-flex flex-wrap gap-3 text-secondary small">
              <span>Move: WASD / Arrow Keys</span>
              <span>Plant Bomb: B</span>
              <span>Pause: Button</span>
            </div>
          </div>
        </div>

        <div class="col-lg-5">
          <div class="panel p-4 mb-4">
            <div class="d-flex justify-content-between align-items-center mb-3">
              <div>
                <div class="text-uppercase text-info small">Bomber</div>
                <div class="fs-5 fw-semibold">{{ vm.player.name }}</div>
              </div>
              <span class="stat-pill">Lives {{ vm.player.lives }}</span>
            </div>
            <div class="mb-3">
              <div class="d-flex justify-content-between small">
                <span>Shield</span>
                <span>{{ vm.player.health }} / {{ vm.player.maxHealth }}</span>
              </div>
              <div class="mini-bar">
                <span style="width: {{ vm.player.health / vm.player.maxHealth * 100 }}%"></span>
              </div>
            </div>
            <div class="mb-3">
              <div class="d-flex justify-content-between small">
                <span>Bomb Power</span>
                <span>{{ vm.player.bombPower }}</span>
              </div>
              <div class="mini-bar">
                <span style="width: {{ vm.player.bombPower * 20 }}%"></span>
              </div>
            </div>
            <div class="row g-2 text-center mb-3">
              <div class="col-4">
                <div class="floating-card">
                  <div class="text-uppercase text-secondary small">Bombs</div>
                  <div class="fw-semibold">{{ vm.player.bombsAvailable }}</div>
                </div>
              </div>
              <div class="col-4">
                <div class="floating-card">
                  <div class="text-uppercase text-secondary small">Speed</div>
                  <div class="fw-semibold">{{ vm.player.speed }}</div>
                </div>
              </div>
              <div class="col-4">
                <div class="floating-card">
                  <div class="text-uppercase text-secondary small">Stage</div>
                  <div class="fw-semibold">{{ vm.stage }}</div>
                </div>
              </div>
            </div>
            <div class="d-flex flex-wrap gap-2">
              <span class="stat-pill">Active Bombs: {{ vm.bombs.length }}</span>
              <span class="stat-pill">Crates: {{ vm.crates.length }}</span>
              <span class="stat-pill">Enemies: {{ vm.enemies.length }}</span>
              <span class="stat-pill">Arena: {{ vm.biome }}</span>
            </div>
          </div>

          <div class="panel p-4 mb-4">
            <h5 class="mb-3">Power Modules</h5>
            <div class="d-flex flex-wrap gap-2">
              <span class="badge text-bg-info" ng-repeat="relic in vm.player.modules track by $index">
                {{ relic }}
              </span>
              <span class="text-secondary" ng-if="vm.player.modules.length === 0">
                No modules collected yet.
              </span>
            </div>
            <div class="mt-3">
              <div class="small text-secondary mb-2">Active Perks</div>
              <ul class="list-unstyled mb-0">
                <li ng-repeat="perk in vm.player.perks track by $index">â€¢ {{ perk }}</li>
              </ul>
            </div>
          </div>

          <div class="panel p-4">
            <h5 class="mb-3">Combat Feed</h5>
            <div class="log">
              <div ng-repeat="entry in vm.log track by $index">{{ entry }}</div>
            </div>
          </div>
        </div>
      </div>

      <div class="row g-4 mt-2">
        <div class="col-lg-8">
          <div class="panel p-4">
            <h5 class="mb-3">Upgrade Bay</h5>
            <div class="row g-3">
              <div class="col-md-4" ng-repeat="upgrade in vm.upgrades track by $index">
                <div class="floating-card h-100 d-flex flex-column">
                  <div class="fw-semibold">{{ upgrade.name }}</div>
                  <div class="text-secondary small mb-3">{{ upgrade.description }}</div>
                  <button class="btn btn-sm btn-outline-info mt-auto" ng-click="vm.pickUpgrade(upgrade)">
                    Install
                  </button>
                </div>
              </div>
            </div>
          </div>
        </div>
        <div class="col-lg-4">
          <div class="panel p-4 h-100">
            <h5 class="mb-3">Mission Intel</h5>
            <ul class="list-unstyled mb-2">
              <li>Enemies Remaining: <span class="accent">{{ vm.enemies.length }}</span></li>
              <li>Crates Remaining: <span class="accent">{{ vm.crates.length }}</span></li>
              <li>Next Module: <span class="accent">{{ vm.nextReward }}</span></li>
              <li>Threat Level: <span class="accent">{{ vm.threatLevel }}</span></li>
            </ul>
            <div class="text-secondary small">
              Clear the arena to advance. Power modules boost bomb capacity, shielding, and speed.
            </div>
          </div>
        </div>
      </div>
    </div>

    <script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.8.3/angular.min.js"></script>
    <script>
      angular
        .module("rogueGame", [])
        .controller("GameController", function ($document, $interval, $scope) {
          const vm = this;
          const size = 9;
          const keyState = new Set();

          vm.biomes = ["Neon Dock", "Arcade Grid", "Ion Foundry", "Circuit Vault", "Void Rift"];
          vm.biome = vm.biomes[0];
          vm.nextReward = "Relic Cache";
          vm.threatLevel = "Alpha";
          vm.paused = false;

          vm.player = {
            name: "Blitz",
            x: 1,
            y: 1,
            health: 100,
            maxHealth: 100,
            lives: 3,
            bombsAvailable: 1,
            bombPower: 2,
            speed: "Normal",
            modules: [],
            perks: ["Blast Suit", "Quick Fuse"],
          };

          vm.stage = 1;
          vm.log = ["Welcome to Gridfall Arena."];
          vm.enemies = [];
          vm.walls = [];
          vm.crates = [];
          vm.bombs = [];
          vm.explosions = [];
          vm.upgrades = [];
          vm.board = [];

          const upgradePool = [
            {
              name: "Fuse Accelerator",
              description: "Increase bomb capacity by 1.",
              apply: () => {
                vm.player.bombsAvailable += 1;
                vm.player.modules.push("Fuse Accelerator");
              },
            },
            {
              name: "Blast Core",
              description: "Increase bomb power by 1.",
              apply: () => {
                vm.player.bombPower += 1;
                vm.player.modules.push("Blast Core");
              },
            },
            {
              name: "Shield Patch",
              description: "Repair 20 shield health.",
              apply: () => {
                vm.player.health = Math.min(vm.player.maxHealth, vm.player.health + 20);
                vm.player.modules.push("Shield Patch");
              },
            },
            {
              name: "Speed Boots",
              description: "Boost movement speed tier.",
              apply: () => {
                vm.player.speed = "Fast";
                vm.player.modules.push("Speed Boots");
              },
            },
            {
              name: "Reinforced Vest",
              description: "Increase max health by 15.",
              apply: () => {
                vm.player.maxHealth += 15;
                vm.player.health += 15;
                vm.player.modules.push("Reinforced Vest");
              },
            },
            {
              name: "Extra Life",
              description: "Gain an extra life.",
              apply: () => {
                vm.player.lives += 1;
                vm.player.modules.push("Extra Life");
              },
            },
          ];

          vm.spawnStage = () => {
            vm.enemies = [];
            vm.walls = [];
            vm.crates = [];
            generateWalls();
            generateCrates();
            const count = 2 + vm.stage;
            for (let i = 0; i < count; i += 1) {
              const position = randomOpenCell();
              vm.enemies.push({
                id: i,
                x: position.x,
                y: position.y,
                health: 1,
              });
            }
            vm.bombs = [];
            vm.explosions = [];
            vm.biome = vm.biomes[(vm.stage - 1) % vm.biomes.length];
            vm.nextReward = upgradePool[Math.floor(Math.random() * upgradePool.length)].name;
            vm.threatLevel = ["Alpha", "Beta", "Gamma", "Omega"][Math.min(vm.stage - 1, 3)];
            vm.log.unshift(`Stage ${vm.stage} deployed. Clear the grid.`);
            updateBoard();
          };

          vm.pickUpgrade = (upgrade) => {
            upgrade.apply();
            vm.log.unshift(`Installed ${upgrade.name}.`);
            refreshUpgrades();
          };

          vm.restart = () => {
            vm.stage = 1;
            vm.player.x = 1;
            vm.player.y = 1;
            vm.player.health = 100;
            vm.player.maxHealth = 100;
            vm.player.lives = 3;
            vm.player.bombsAvailable = 1;
            vm.player.bombPower = 2;
            vm.player.speed = "Normal";
            vm.player.modules = [];
            vm.player.perks = ["Blast Suit", "Quick Fuse"];
            vm.log = ["Run restarted. Plant those bombs!"];
            vm.biome = vm.biomes[0];
            refreshUpgrades();
            vm.spawnStage();
          };

          vm.togglePause = () => {
            vm.paused = !vm.paused;
            vm.log.unshift(vm.paused ? "Paused." : "Resumed." );
          };

          function refreshUpgrades() {
            vm.upgrades = shuffle([...upgradePool]).slice(0, 3);
          }

          function randomOpenCell({ avoidWalls = true, avoidCrates = true } = {}) {
            let x = 0;
            let y = 0;
            let occupied = true;
            while (occupied) {
              x = Math.floor(Math.random() * size);
              y = Math.floor(Math.random() * size);
              occupied =
                (x === vm.player.x && y === vm.player.y) ||
                vm.enemies.some((enemy) => enemy.x === x && enemy.y === y) ||
                (avoidWalls && vm.walls.some((wall) => wall.x === x && wall.y === y)) ||
                (avoidCrates && vm.crates.some((crate) => crate.x === x && crate.y === y));
            }
            return { x, y };
          }

          function generateWalls() {
            vm.walls = [];
            for (let row = 0; row < size; row += 1) {
              for (let col = 0; col < size; col += 1) {
                if (row === 0 || col === 0 || row === size - 1 || col === size - 1) {
                  vm.walls.push({ x: col, y: row });
                } else if (row % 2 === 0 && col % 2 === 0) {
                  vm.walls.push({ x: col, y: row });
                }
              }
            }
            const safeZone = [
              { x: 1, y: 1 },
              { x: 1, y: 2 },
              { x: 2, y: 1 },
            ];
            vm.walls = vm.walls.filter(
              (wall) => !safeZone.some((safe) => safe.x === wall.x && safe.y === wall.y)
            );
          }

          function generateCrates() {
            const desiredCrates = Math.min(24, 10 + vm.stage * 2);
            let attempts = 0;
            while (vm.crates.length < desiredCrates && attempts < desiredCrates * 10) {
              const spot = randomOpenCell({ avoidWalls: true, avoidCrates: false });
              const alreadyCrate = vm.crates.some((crate) => crate.x === spot.x && crate.y === spot.y);
              if (!alreadyCrate) {
                vm.crates.push(spot);
              }
              attempts += 1;
            }
          }

          function updateBoard() {
            vm.board = Array.from({ length: size * size }, () => ({ type: "empty" }));
            const playerIndex = vm.player.y * size + vm.player.x;
            vm.board[playerIndex] = { type: "player", shielded: vm.player.health > 50 };

            vm.walls.forEach((wall) => {
              const index = wall.y * size + wall.x;
              vm.board[index] = { type: "wall" };
            });

            vm.crates.forEach((crate) => {
              const index = crate.y * size + crate.x;
              vm.board[index] = { type: "crate" };
            });

            vm.bombs.forEach((bomb) => {
              const index = bomb.y * size + bomb.x;
              vm.board[index] = { type: "bomb" };
            });

            vm.explosions.forEach((blast) => {
              const index = blast.y * size + blast.x;
              vm.board[index] = { type: "explosion" };
            });

            vm.enemies.forEach((enemy) => {
              const index = enemy.y * size + enemy.x;
              vm.board[index] = { type: "enemy" };
            });
          }

          function movePlayer(dx, dy) {
            const targetX = clamp(vm.player.x + dx);
            const targetY = clamp(vm.player.y + dy);
            if (
              vm.walls.some((wall) => wall.x === targetX && wall.y === targetY) ||
              vm.crates.some((crate) => crate.x === targetX && crate.y === targetY) ||
              vm.bombs.some((bomb) => bomb.x === targetX && bomb.y === targetY)
            ) {
              vm.log.unshift("Path blocked.");
              return;
            }
            vm.player.x = targetX;
            vm.player.y = targetY;
            updateBoard();
          }

          function clamp(value) {
            return Math.max(0, Math.min(size - 1, value));
          }

          function dropBomb() {
            if (vm.bombs.length >= vm.player.bombsAvailable) {
              vm.log.unshift("Bomb limit reached.");
              return;
            }
            const existingBomb = vm.bombs.some(
              (bomb) => bomb.x === vm.player.x && bomb.y === vm.player.y
            );
            if (existingBomb) {
              vm.log.unshift("Bomb already planted.");
              return;
            }
            vm.bombs.push({
              x: vm.player.x,
              y: vm.player.y,
              timer: 6,
              power: vm.player.bombPower,
            });
            vm.log.unshift("Bomb planted.");
            updateBoard();
          }

          function enemyTurn() {
            if (vm.paused) {
              return;
            }
            vm.enemies.forEach((enemy) => {
              const directions = shuffle([
                { x: 1, y: 0 },
                { x: -1, y: 0 },
                { x: 0, y: 1 },
                { x: 0, y: -1 },
              ]);
              for (const direction of directions) {
                const nextX = clamp(enemy.x + direction.x);
                const nextY = clamp(enemy.y + direction.y);
                const blocked =
                  vm.walls.some((wall) => wall.x === nextX && wall.y === nextY) ||
                  vm.crates.some((crate) => crate.x === nextX && crate.y === nextY) ||
                  vm.bombs.some((bomb) => bomb.x === nextX && bomb.y === nextY);
                if (!blocked) {
                  enemy.x = nextX;
                  enemy.y = nextY;
                  break;
                }
              }
              if (enemy.x === vm.player.x && enemy.y === vm.player.y) {
                handlePlayerHit("Enemy collision!");
              }
            });
            updateBoard();
          }

          function handlePlayerHit(message) {
            vm.player.health -= 30;
            vm.log.unshift(message);
            if (vm.player.health <= 0) {
              vm.player.lives -= 1;
              if (vm.player.lives <= 0) {
                vm.log.unshift("Game over. Restart to try again.");
                vm.paused = true;
                return;
              }
              vm.player.health = vm.player.maxHealth;
              vm.player.x = 1;
              vm.player.y = 1;
              vm.log.unshift("Life lost. Resetting position.");
            }
          }

          function shuffle(array) {
            return array
              .map((value) => ({ value, sort: Math.random() }))
              .sort((a, b) => a.sort - b.sort)
              .map(({ value }) => value);
          }

          function handleKey(event) {
            if (vm.paused) {
              return;
            }
            if (keyState.has(event.code)) {
              return;
            }
            keyState.add(event.code);
            switch (event.code) {
              case "ArrowUp":
              case "KeyW":
                movePlayer(0, -1);
                break;
              case "ArrowDown":
              case "KeyS":
                movePlayer(0, 1);
                break;
              case "ArrowLeft":
              case "KeyA":
                movePlayer(-1, 0);
                break;
              case "ArrowRight":
              case "KeyD":
                movePlayer(1, 0);
                break;
              case "KeyB":
                dropBomb();
                break;
              default:
                break;
            }
            $scope.$applyAsync();
          }

          function releaseKey(event) {
            keyState.delete(event.code);
          }

          $document.on("keydown", handleKey);
          $document.on("keyup", releaseKey);

          const enemyInterval = $interval(enemyTurn, 900);
          const bombInterval = $interval(() => {
            if (vm.paused) {
              return;
            }
            vm.bombs.forEach((bomb) => {
              bomb.timer -= 1;
            });
            const detonations = vm.bombs.filter((bomb) => bomb.timer <= 0);
            if (detonations.length) {
              detonations.forEach((bomb) => explodeBomb(bomb));
              vm.bombs = vm.bombs.filter((bomb) => bomb.timer > 0);
            }
            vm.explosions.forEach((blast) => {
              blast.timer -= 1;
            });
            vm.explosions = vm.explosions.filter((blast) => blast.timer > 0);
            updateBoard();
          }, 300);

          $scope.$on("$destroy", () => {
            $interval.cancel(enemyInterval);
            $interval.cancel(bombInterval);
            $document.off("keydown", handleKey);
            $document.off("keyup", releaseKey);
          });

          refreshUpgrades();
          vm.spawnStage();

          function explodeBomb(bomb) {
            const blastCells = [{ x: bomb.x, y: bomb.y }];
            const directions = [
              { x: 1, y: 0 },
              { x: -1, y: 0 },
              { x: 0, y: 1 },
              { x: 0, y: -1 },
            ];
            directions.forEach((direction) => {
              for (let step = 1; step <= bomb.power; step += 1) {
                const target = { x: bomb.x + direction.x * step, y: bomb.y + direction.y * step };
                if (vm.walls.some((wall) => wall.x === target.x && wall.y === target.y)) {
                  break;
                }
                blastCells.push(target);
                const crateIndex = vm.crates.findIndex(
                  (crate) => crate.x === target.x && crate.y === target.y
                );
                if (crateIndex >= 0) {
                  vm.crates.splice(crateIndex, 1);
                  break;
                }
              }
            });
            blastCells.forEach((cell) => {
              vm.explosions.push({ x: cell.x, y: cell.y, timer: 2 });
              vm.enemies = vm.enemies.filter((enemy) => enemy.x !== cell.x || enemy.y !== cell.y);
              if (vm.player.x === cell.x && vm.player.y === cell.y) {
                handlePlayerHit("Caught in explosion!");
              }
            });
            vm.log.unshift("Bomb detonated!");
            checkStageClear();
          }

          function checkStageClear() {
            if (vm.enemies.length === 0) {
              vm.stage += 1;
              vm.player.health = Math.min(vm.player.maxHealth, vm.player.health + 15);
              vm.log.unshift("Stage cleared! Advancing.");
              vm.spawnStage();
            }
          }
        });
    </script>
  </body>
</html>
